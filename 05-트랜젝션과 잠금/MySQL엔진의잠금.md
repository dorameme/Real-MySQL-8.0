
## 5.2 MySQL 엔진의 잠금

* **분류:** MySQL 잠금은 크게 두 레벨로 나뉜다.

  1. **MySQL 엔진 레벨 잠금:** 스토리지엔진을 제외한 MySQL 자체 레벨에서 관리. 모든 스토리지엔진에 영향.
  2. **스토리지엔진 레벨 잠금:** 특정 스토리지엔진(InnoDB, MyISAM 등)에서 관리. 엔진 간에는 영향 없음.

# 5.2 MySQL 엔진의 잠금

## 5.2.1 글로벌 락 (Global Lock)

### 1. 개념
- **MySQL 서버 전체**에 영향을 미치는 잠금
- `FLUSH TABLES WITH READ LOCK` 명령으로 획득
- 모든 데이터베이스의 모든 테이블에 영향을 미침

### 2. 특징
- **범위**: 전체 MySQL 서버
- **영향**: 모든 스토리지 엔진 (InnoDB, MyISAM 등)
- **동시성**: 읽기만 가능, 쓰기 작업 모두 차단
- **세션 영향**: 잠금을 획득한 세션에서만 해제 가능

### 3. 실무 쓰임
- **백업 작업**: 논리적 백업 시 데이터 일관성 보장
- **복제 설정**: 마스터-슬레이브 설정 시
- **스키마 마이그레이션**: 전체 데이터베이스 일관성 유지 필요 시
- **주의사항**: 장시간 사용 시 서비스 중단 발생 가능

```sql
-- 글로벌 락 획득
FLUSH TABLES WITH READ LOCK;

-- 백업 작업 수행 (mysqldump 등)

-- 글로벌 락 해제
UNLOCK TABLES;
```

## 5.2.2 테이블 락 (Table Lock)

### 1. 개념
- **개별 테이블** 단위로 설정되는 잠금
- 명시적: `LOCK TABLES table_name [READ|WRITE]`
- 묵시적: MyISAM에서 데이터 변경 시 자동 획득

### 2. 특징
- **범위**: 단일 테이블
- **동시성**: 
  - READ lock: 여러 세션 읽기 가능, 쓰기 차단
  - WRITE lock: 단일 세션 읽기/쓰기 가능, 다른 세션 모두 차단
- **세션 영향**: 동일 세션에서만 잠금 해제 가능

### 3. 실무 쓰임
- **MyISAM 테이블**: 데이터 변경 시 자동 테이블 락
- **일괄 처리**: 대량 데이터 일괄 처리 시 임시 락
- **마이그레이션**: 특정 테이블 구조 변경 시
- **InnoDB 제한**: InnoDB에서는 거의 사용되지 않음

```sql
-- 테이블 읽기 잠금
LOCK TABLES employees READ;

-- 작업 수행
SELECT * FROM employees;

-- 잠금 해제
UNLOCK TABLES;
```

## 5.2.3 네임드 락 (Named Lock)

### 1. 개념
- **사용자 정의 잠금**으로 특정 문자열에 대한 잠금
- `GET_LOCK()` 함수로 획득, `RELEASE_LOCK()`으로 해제
- 테이블/행과 무관한 논리적 잠금

### 2. 특징
- **범위**: 문자열 기반 논리적 잠금
- **세션 독립적**: 다른 세션과 잠금 공유 가능
- **타임아웃**: 잠금 대기 시간 설정 가능
- **유연성**: 어떤 리소스에도 사용 가능

### 3. 실무 쓰임
- **분산 락**: 여러 애플리케이션 서버 간 동기화
- **리소스 동기화**: 외부 리소스 접근 제어
- **배치 작업**: 중복 실행 방지
- **마이그레이션**: 데이터 마이그레이션 동기화

```sql
-- 네임드 락 획득 (5초 대기)
SELECT GET_LOCK('order_processing_lock', 5);

-- 크리티컬 섹션 작업
UPDATE orders SET status = 'processing' WHERE order_id = 1001;

-- 네임드 락 해제
SELECT RELEASE_LOCK('order_processing_lock');
```

## 5.2.4 메타데이터 락 (Metadata Lock)

### 1. 개념
- **데이터베이스 객체의 구조(스키마)**를 보호하는 잠금
- DDL(CREATE, ALTER, DROP)과 DML(SELECT, INSERT 등) 간 충돌 방지
- 자동으로 획득 및 해제되는 암시적 잠금

### 2. 특징
- **자동 관리**: 명시적 락 획득/해제 불필요
- **충돌 방지**: DDL과 DML 작업 간 간섭 방지
- **범위**: 데이터베이스 객체 (테이블, 뷰, 프로시저 등)
- **격리 수준**: 트랜잭션 격리 수준 영향 받음

### 3. 실무 쓰임
- **온라인 DDL**: 스키마 변경 시 데이터 접근 보호
- **무중단 배포**: 애플리케이션 업데이트 시
- **복제 환경**: 마스터-슬레이브 간 일관성 유지
- **문제 상황**: 장기 실행 트랜잭션이 DDL 차단 시

```sql
-- 세션 1: 장기 트랜잭션
START TRANSACTION;
SELECT * FROM large_table; -- 메타데이터 락 획득

-- 세션 2: DDL 시도 (대기 상태)
ALTER TABLE large_table ADD COLUMN new_column INT;
```


| 잠금 유형 | 범위 | 사용 명령어 | 주요 용도 |
|-----------|------|-------------|-----------|
| **글로벌 락** | 전체 서버 | `FLUSH TABLES WITH READ LOCK` | 전체 백업 |
| **테이블 락** | 단일 테이블 | `LOCK TABLES` | MyISAM 작업 |
| **네임드 락** | 논리적 문자열 | `GET_LOCK()` | 분산 동기화 |
| **메타데이터 락** | 데이터베이스 객체 | 자동 관리 | DDL/DML 충돌 방지 |

## 실무 적용 팁


1. 글로벌 락 → 거의 사용 안 함, 대신 트랜잭션 기반 백업 사용

2. 테이블 락 → InnoDB 환경에서는 거의 필요 없음, 레거시 MyISAM에서만 사용

3. 네임드 락 → 분산 락/논리적 동기화 용도로 제한적 사용

4. 메타데이터 락(MDL) → 항상 자동 발생, DDL/DML 충돌 방지 때문에 지금도 핵심
- 메타데이터 락(MDL)은 사용자가 직접 걸지는 않는다.
- MySQL이 DDL(DROP/ALTER/RENAME 등)이나 DML(SELECT, INSERT, UPDATE, DELETE) 시 자동으로 관리한다.
-  즉, 개발자는 MDL을 명시적으로 호출하거나 설정할 필요가 없다.
- 실무에서 개발자가 직접 쓸 필요 없음 대신 MDL로 인해 DDL이 대기하는 현상은 인지하고 있어야 함
